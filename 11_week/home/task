1.
  - Модифицируемый объект должен оставаться модифицируемым.  X& (неконстанотное l-значение)
  - Константный объект должен быть передан ка кобъект, предназначенный только для чтения.  const X& (константное 1-значение)
  - Перемещаемый объект (из которого можно “украсть” его внутреннее содержимое за ненужностью) должен передаваться как перемещаемый объект.
Для избежания дублирования используем std::forward и универсальные ссылки
X&& (неконстантное1-значение, необходим std::move() для вызова g(X&&))

2.
T&&v, auto&&
Универсальные ссылки -ссылки в контексте вывода типов, которые могут превратиться в r-value или в l-value ссылку, в зависимости от того, что мы передаём,
если тип выводится компилятором, то это универсальная ссылка

3.
Игнорирование шаблона, если он не подходит, т.е. если не получается рассчитать окончательные типы аргументов перегруженной шаблонной функции, 
компилятор не выбрасывает ошибку, а ищет другую подходящую перегрузку

4.
Упаковка возвращаемого типа функции(не применимо к конструкторам/операторам)
Добавление параметра функции с аргументом по умолчанию
Добавление параметра шаблона с аргументом по умолчанию (по умолчанию тип void)
Упаковка нешаблонного аргумента
Выбор типа аргумента по умолчанию(добавление параметра функции с аргументом по умолчанию)

5.
Шаблонная функция принимает по обычной r-value ссылке
при f(T& arg): 
int x = 42;         f(x) -> T = int , int&
const int cx = x;   f(cx) -> T = const int , const int&
const int& rx = x;  f(rx) -> T = const int , const int&
Шаблонная функция принимает по универсальной ссылке 
при f(T && arg):  
int x = 42;         f(x) -> T = int& , int& && -> int & //свертывание тут и дальше
const int cx = x;   f(cx) -> T = const int & , const int & && -> const int&
const int& rx = x;  f(rx) -> T = const int & , const int & && -> const int&
42;                 f(42) -> T = int, int &&

