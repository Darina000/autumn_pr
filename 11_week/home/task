1.
forward
универсальные ссылки
  - Модифицируемый объект должен оставаться модифицируемым.  X& (неконстанотное l-значение)
  - Константный объект должен быть передан ка кобъект, предназначенный только для чтения.  const X& (константное 1-значение)
  - Перемещаемый объект (из которого можно “украсть” его внутреннее содержимое за ненужностью) должен передаваться как перемещаемый объект. 
X&& (неконстантное1-значение, необходим std::move() для вызова g(X&&))

2.
T&&v, auto&&
Универсальные ссылки - rvalue-ссылки в контексте вывода типов, которая может быть связана с изменяемым, константным или перемещаемым объектом.

3.
Игнорирование шаблона, если он не подходит, т.е. если не получается рассчитать окончательные типы аргументов перегруженной шаблонной функции, 
компилятор не выбрасывает ошибку, а ищет другую подходящую перегрузку

4.
Упаковка возвращаемого типа функции(не применимо к конструкторам/операторам)
Добавление параметра функции с аргументом по умолчанию
Добавление параметра шаблона с аргументом по умолчанию (по умолчанию тип void)
Упаковка нешаблонного аргумента
Выбор типа аргумента по умолчанию(добавление параметра функции с аргументом по умолчанию)

5.
там как выводится тип T если у нас универсальная ссылка и как выв т если р-валие ссылка // есть в конспекте 
????
- передача по значению (по умолчанию)
  - выполняется копирование
  -можно использовать std::ref() std::cref()
  -безопаснее для возвращаемого значения
  -есть низведение типа для общности
 - передача по ссылке
  - лучшая производительность
  - модификация исходных объектов
  - пробрасывающий шаблон
