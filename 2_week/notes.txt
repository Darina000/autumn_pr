int x{0}; - унифицированная фигурная инициализация 
std::endl; - делает два действия - перенос строки и flush(опустошение буфера)
в числах с плавающей точкой исчисления писать 1.0/200.0
Данные:  
объекты - ячейка памяти с адресом 
доступ : имя переменной, адрес ячейки памяти, адрес хранится в указатели (указатель это переменная, которая хранит в себе адрес)

Низкоуровневые средства(сложный код, проблемы с памятью)
Указатели,  ссылки
Встроенные массивы []: фиксированные и динамические 

Высокоуровневые замены:
smart pointers
контейнеры(STD): фиксированные и динамические 

Указатели
Встроенные массивы 
Массивы переменного размера
Динамический массив - мы сразу запрашиваем какое-то место в пямяти 
Оператор new выделяет блок памяти (динамическое выделение памяти )
Статическая область памяти хранит глобальные переменные 
Если в main определит int x; int y; они пойдут в стэк (стэк для небольших данных)
Куча для больших данных 

Встроенный массив, не динамический при int a[1000000] будет ошибка
Для динамических массивов(память выделяется в куче) с “new” 

Утечка памяти - valgrin - система, что отслеживает утечки памяти:
delete ptr1;  возвтращается память одной переменнрй 
delete[] ptr2; возвращается память массива

Пробемы(в низкоуровневых )
Забыть delete;
Написать не тот delete;
Написать лишний delete
арифметика указателей 
разменоваие nullptr

Функции при объявлении нужно передавать указааель на массив(те н апервый его элемент ) и размер этого массива 

const int * p // нельзя менять данные 
int * const  p  // нельзя менять указатель

передача данных в функцию 
void f(int x){x++} по значению, копирование 
void f(int *x){*x++} по указателю, нет копирования , тут можно добавлять const для избежания изменения, вызов через &
void f(int &x){x++} нет копирования, вызов обычный, но при f(x), ч меняется 

Ссылка - автоматически разыменованный при использовании //не нужно писать *, работает напрямую с данными без взятия по адресу// const указатель//не можем поменять указатель//,  без поддержки nullptr режима // должны обязательно инициализировать, обязана на что-то ссылаться 

Константная ссылка - const int & -указывает на данные, которые нельзя менять 


Работа с многомерными массивами 


#include “string”
std::string name;
name.size() // узнаем размер текущей строки name 
name.substr() // вырезает кусок строки заданной длины в заданном месте
name.find(“av”) // поиск подстроки, найдет индекс, когда av попадает в строку name 

auto substring = name.substr(result, 2// сколько элементов) // вырезается, тип срез  

#include <vector> - вектор - динамический массив 
Гомогенные контейнеры = хранит данные одного типа 

acm.mipt.ru - подобие решения для последней задачи 
sort(v.begin(), v.end(() - ировка
