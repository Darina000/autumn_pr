
ОПП

Инвариант - утверждение, что верно в любой момент времени, 

Концепции ОПП: 
инкапсуляция (объединение данных и ф-членов в рамках одного класса, публичный интерфейс(ф-члены), приватные данные(это доступно только ф-членам)), инвариант должен быть сохранен, но может нарушить при функции (будет проходить внутри ф-члена), главное, чтоб было видно из вне сохранение
полиморфизм - одинаковый интерфейс, разные реализации (вычисление площади для разных  фигур )
наследование  - студент наследник человека
*абстракция


В структуре - всё паблик по умолчанию, в классах все приват 

Явные и неявные преобразования(дополнение cстр

Правило - маленькие функции внутри, большие - разделять 

Объявление классов- всё кроме реализации ф-членов, если есть и они, то это определение 

class X; - неполное объявление 
этап подключения #include - директива препроцессинга
.сpp  - main пишем #include jjj.hpp 
.cpp - f  ///переходит в юниты трансляции после препроцессинга 
.cpp - g    ///переходит в юниты трансляции после препроцессинга 
.hpp - header file - объявление g и f
Компиляция
Скомпилированные юниты трансляции ддд.obj - объектные файлы
потом идёт линковка (компоновщик), всё соединяется , до сюдого у нас только объявления в мейне и определения в f and g
Получается exe программа 
Ошибки:
нет моста  //LNK 2019 неразрешенный внешний символ (просто убираем объявление)
неоднозначный мостик//LNK 1169 - неоднократно определенный символ 

Внешнее связывание - f, g имеет внешнее связывание, доступно из другие юнитов трансляциии 
Внутреннее связывание  - доступность только в данном юните трансляции 

Запись вида  (тогда не видно)
namespase{
тут void f(){
rgd
}
}
в Hpp не надо определение - очень плохо 



в дз - на остнове глобальных переменных в 
для объявлением в hpp для глобальных переменных extern int x;
в сpp писать без const/static



Правило ODR - one definition rule (один раз объявил много определил )

# - команда вызова директива препроцессинга
Если написать #pragma once - один раз чтоб подключать инклуды
или
#ifndef HEADER_HPP
#define HEADER_HPP
тут код наш 
#endif /* f_hpp */
 
Пространство имён:
std:: 
namespace test1{
void f(){
	std::cout << "test 1" << std::endl;
}
}
namespace tes2t{
void f(){
	std::cout << "test 2" << std::endl;
}
}

тогда test1::f();

Из свойст пространсва имён :
можно делать вложенные пространства имён 
аддитивность (можно дополнять кусками, оно объединится),  может работать по файлам 

Статические члены класса: 
class X{
public:
	static const double x;
}
const double X::pi = 3.14
не принадлежат конкретному экземпляру

существуют статические функции, они не принадлежат конкретному (сохранение или печать ставку, что общаяя для всех)

В дз - 2 задача, перевод системы единиц - использовать стат константы для перевода в эВ и тд

Друзья

friend 
<<  оператор 
count << x; // 	инфиксная (оператор)

оператор(имя) << (поток, объект)
print(count, x) - свободная функция
x.print(count)

class X{
	operator +( X, x2);
}
X x1;
x1.operator +(x2)
x1+x2 

cout << x
x << cout
x.operator << (cout)


Друг имеет доступ к приватным полям

Ухудшается инкапсуляция при большом количестве друзей 


ДЗ
4ая глобальная переменнтая и extern, 

3- паттерн - подр устойчивая конструкция (найти в гугле, что делать)

