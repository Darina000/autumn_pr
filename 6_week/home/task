1.
  1) конструктор по умолчанию
  2) пользовательский конструктор
  3) деструктор 
  4) оператор = ( копирования )
  5) оператор = (перемещения)
  6) копирующий конструктор
  7) конструктор перемещающий 
2.

-> () [] - можно
& , - не рекомендуется 
::  .  (*. доп) - нельзя
также нельзя унарный %, или тернарный +

3.

Нужно помнить о неявных преобразованиях, чтоб с ними не возникновеникло ошибок нужно делать конструкторы явными, используя explicit.

4.
идентифицируемость(i)
перемещаемость(m)

lvalue (i& !m) это int x;
xvalue (i&m)
prvalue(!i&m)  это 10
glvalue(i) почти не затрагиваем,  general категория для lvalue and xvalue
rvalue (m) general категория для xvalue and prvalue

5.
Неконстантные ссылки r-value используют в качестве параметра при определение конструктора перемещения и оператора присваивания перемещением.
Неконстантные ссылки r-value позволяют нам изменять значения r-values, на которые указывают ссылки r-value
Они увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-value.
Это полезно при перегрузке функций, когда нужно, чтобы выполнение функции отличалось в зависимости от аргументов (l-values или r-values)

6.

Использование семантики перемещения быстрее, чем с использованием семантики копирования, иногда позволяет избежать избыточного копирования. 

7.

std :: move приводит свой аргумент к ссылке rvalue, чтобы разрешить его перемещение, но не гарантирует операцию перемещения. Например, мы можем написать более эффективную версию подкачки, используя std :: move:

std::move является излишним, когда мы возвращаем локальную переменную по значению -  компилятор поймет, что мы больше не собираемся использовать эту локальную переменную и ее можно переместить, а не копировать.
return std::move (t); - Тк возвращаемое выражение должно быть именем, а std :: move возвращает ссылку, и компилятор не знает, на какой объект функция возвращает ссылку. Таким образом, компилятор выдаст предупреждение
Также, когда объект класса, который возвращает функция, является параметром функции, копирования невозможно. Вызывать return std::move (t); излишне, тк он будет использован в любом случае.

8.
Есть спец перемещающие операторы, что выполняют работу по перемещению 
X(&&X)
X& operator = (X&&)

9.
-----чтоб избежать создания компилятором спец функции-члена по умолчанию, которая нам не подходит
Конструкторы - чтоб инициализировать класс с закрытыми(приватными) переменными-членами,инициализации переменных-членов класса значениями по умолчанию/пользователем, 
или для любых шагов, необходимых для используемого класса.
Деструктор производит последние действия с объектом перед его окончательным уничтожением. То есть, он поможет, если объект класса содержит любые ресурсы или, 
если нужно выполнить какие-либо действия до того, как объект будет уничтожен.
Конструктор копирования — используется для создания нового объекта через копирование существующего объекта. 
Если не предоставитm конструктор копирования самостоятельно, то C++ создаст public-конструктор копирования автоматически и 
по умолчанию созданный конструктор копирования будет использовать почленную инициализацию(каждый член объекта-копии инициализируется из члена объекта-оригинала).
Также и с оператором присваивания -  по умолчанию выполняется почленное присваивание, потому для избежания этого нужно писать самому.


10.

default - суть в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию. 
Например, если у класса есть пользовательский конструктор, то конструктор по ум не будет сгенерирован. Для записи вида Person masha; нужно либо добавить копр конструктора без параметров,
либо использовать default - он сгенерируется по умолч.
delete - нужен для того, чтобы помечать те методы, работать с которыми нельзя. Когда программа ссылается явно или неявно на эту функцию — ошибка на этапе компиляции. 
Запрещается даже создавать указатели на такие функции. Также можно легко запретить конструктор копий или запретить автоматическое приведение типов. 
