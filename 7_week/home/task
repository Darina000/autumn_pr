1.
  1). Композиция (автомобиль с колесом, человек и сердце)  A часть В, под управлением В, отношение однонаправлено- A не знает о B.
  2). Агрегация  A может быть частью сразу B1, B2, B3.. не управляется ними и не знает о них
  3). Ассоциация  - независимые объекты(объекты между собой никак не связаны), используют друг друга (например, студенты и предметы), 
  отношения могут быть как однонаправленными, так и двунаправленными
  4). Зависимость - использование без связи, например, отношения классов и std::cout (типа std::ostream), 
  классы используют std::cout для вывода чего-либо в консоль, но не наоборот. 

2.
Два варианта наследования:
  интерфейса (открытое наследование) - “является разновидностью”
  реализации (закрытое наследование) - “реализован посредством”

Наследование типа public (исп. по умолчанию, если нет причин делать иначе) - открытое наследование,когда мы открыто наследуете родительский класс, то унаследованные члены public остаются public,
унаследованные члены protected остаются protected, а унаследованные члены private остаются недоступными для дочернего класса. Ничего не меняется.

Наследование типа private (исп., чтоб ограничить доступ)- при закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что члены private остаются недоступными,
а члены protected и public становятся private в дочернем классе

Наследование типа protected (исп. очень редко)-защищенное наследование, члены public и protected становятся protected, а члены private остаются недоступными.

3.

1). Нужно указать ключевое слово virtual перед объявлением функции
2). Сигнатура виртуального метода дочернего класса должна полностью соответствовать сигнатуре виртуального метода родительского класса. 
Если у дочернего метода будет другой тип параметров, нежели у родительского, то вызываться этот метод не будет.
3). Нельзя вызывать виртуальные функции в теле конструкторов или деструкторов

4.
Серьезной проблемой является «алмаз смерти» - ситуация, когда один класс имеет 2 родительских класса, 
каждый из которых, в свою очередь, наследует свойства одного и того же родительского класса. 
При создании родительских классов для дочернего мы получим две копии родительского класса - чтоб этого избежать можно создать виртуальный базовый класс(общий для использования всеми дочерними классами)

5.
Основные категории паттернов проектирования:
  -порождающие - эти паттерны отвечают за создание новых объектов или даже целых семейств объектов. Например, фабричный метод — это порождающий паттерн проектирования,
  который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. Т.е. cоздавать объекты не напрямую, 
  используя оператор new, а через вызов особого фабричного метода.
  
  -структурные - отвечают за построение удобных в поддержке иерархий классов. Например, адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
  Это "объект-переводчик", который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
  
  -поведение (поведенческие) - для взаимодействия между объектами программы. Пример - шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма,
  перекладывая ответственность за некоторые его шаги на подклассы. Это позволяет разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом.

