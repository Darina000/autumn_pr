1.
  1) конструктор по умолчанию
  2) пользовательский конструктор
  3) деструктор 
  4) оператор = ( копирования )
  5) оператор = (перемещения)
  6) копирующий конструктор
  7) конструктор перемещающий 
2.

-> () [] - можно
& , - не рекомендуется 
::  .  (*. доп) - нельзя
также нельзя унарный %, или тернарный +

3.

Нужно помнить о неявных преобразованиях, чтоб с ними не возникновеникло ошибок нужно делать конструкторы явными, используя explicit.

4.
идентифицируемость(i)
перемещаемость(m)

lvalue (i& !m) это int x;
xvalue (i&m)
prvalue(!i&m)  это 10
glvalue(i) почти не затрагиваем,  general категория для lvalue and xvalue
rvalue (m) general категория для xvalue and prvalue

5.
Неконстантные ссылки r-value используют в качестве параметра при определение конструктора перемещения и оператора присваивания перемещением.
Неконстантные ссылки r-value позволяют нам изменять значения r-values, на которые указывают ссылки r-value
Они увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-value.
Это полезно при перегрузке функций, когда нужно, чтобы выполнение функции отличалось в зависимости от аргументов (l-values или r-values)

6.

Использование семантики перемещения быстрее, чем с использованием семантики копирования, иногда позволяет избежать избыточного копирования. 

7.

std :: move приводит свой аргумент к ссылке rvalue, чтобы разрешить его перемещение, но не гарантирует операцию перемещения. Например, мы можем написать более эффективную версию подкачки, используя std :: move:

std::move является излишним, когда мы возвращаем локальную переменную по значению -  компилятор поймет, что мы больше не собираемся использовать эту локальную переменную и ее можно переместить, а не копировать.
return std::move (t); - Тк возвращаемое выражение должно быть именем, а std :: move возвращает ссылку, и компилятор не знает, на какой объект функция возвращает ссылку. Таким образом, компилятор выдаст предупреждение
Также, когда объект класса, который возвращает функция, является параметром функции, копирования невозможно. Вызывать return std::move (t); излишне, тк он будет использован в любом случае.

8.

9.

10.

default - суть в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию. 
Например, если у класса есть пользовательский конструктор, то конструктор по ум не будет сгенерирован. Для записи вида Person masha; нужно либо добавить копр конструктора без параметров,
либо использовать default - он сгенерируется по умолч.
delete - нужен для того, чтобы помечать те методы, работать с которыми нельзя. Когда программа ссылается явно или неявно на эту функцию — ошибка на этапе компиляции. 
Запрещается даже создавать указатели на такие функции. Также можно легко запретить конструктор копий или запретить автоматическое приведение типов. 
